module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    
    output red,
    output green,
    output blue,
    output hsync,
    output vsync,
    
    input a_button,
    input u_button,
    input d_button,
    input r_button,
    input l_button
     
  ) {
  
  sig rst;                  // reset signal

  
  .clk(clk){
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    dff pixel[11];
    dff line[11];
    
    edge_detector edge_detector(#RISE(1), #FALL(0));
    // this is for the user position
    dff userX[11](#INIT(400), .rst(rst));
    dff userY[11](#INIT(480), .rst(rst));
    
    
    dff timer[23](.rst(rst));
    dff scheduler[20](.rst(rst));
    //fsm scheduler(#INIT(U_BUTTON)) = {U_BUTTON, D_BUTTON, L_BUTTON, R_BUTTON};
  }
  

  enemy enemyChar;
  projectile projChar;
  aluLogic alu;               // alu
  user userChar;              // user sprite
  background bg;            // enemy sprite


  always {
    alu.a = 0;
    alu.b = 0;
    alu.alufn = 0;
    
    reset_cond.in = ~rst_n;   // input raw inverted reset signal
    rst = reset_cond.out;     // conditioned reset
    
    led = 8h00;               // turn LEDs off
    spi_miso = bz;            // not using SPI
    spi_channel = bzzzz;      // not using flags
    avr_rx = bz;              // not using serial port
    
    
    // Scheduler
    // To change the value depending on the number of operations we are doing
    //if(scheduler.q[5] == 1){
    //  scheduler.d = 0;
    //} else {
    scheduler.d = scheduler.q + 1; 
    //}
    

    // BG element
    bg.clk = clk;
    bg.rst = rst;
    bg.cursorX = 300;
    bg.cursorY = 300;

    // prepare edge detector for a_button
    edge_detector.in = a_button;

    
    // Controlling Position enemy
    enemyChar.cursorX = pixel.q;
    enemyChar.cursorY = line.q;
    enemyChar.clk = clk;
    enemyChar.rst = rst;
    
    

    //Projectile Parameters
    projChar.clk = clk;
    projChar.rst = rst;
    projChar.cursorX = pixel.q;
    projChar.cursorY = line.q;
    projChar.hit = 0;
    projChar.shot = 0;

    
    
    // Controlling Position User
    // User Controls

    userChar.cursorX = pixel.q;
    userChar.cursorY = line.q;
    timer.d = timer.q + 1;          // Use timer to prevent the values from skyrocketting

    
    
    
    // Button control
    // Use timer to prevent the values from skyrocketting
    userChar.charX = userX.q;
    userChar.charY = userY.q;
    
    // Scheduler M.1
    if(scheduler.q == 524288){
      if(u_button == 1 && userY.q >= 340){
        // userY.d = userY.q - 1;
        alu.a = c{21b0, userY.q};
        alu.b = 2;
        alu.alufn = b000001;
        userY.d = alu.aluOUT[10:0];
        scheduler.d = 11;
      }
    }
      
    // Scheduler M.2
    if(scheduler.q == 524287){
      if(d_button == 1 && userY.q <= 550){
        //userY.d = userY.q + 1;
        alu.a = c{21b0, userY.q};
        alu.b = 2;
        alu.alufn = b000000;
        userY.d = alu.aluOUT[10:0];
        scheduler.d = 10;
      } 
    }
      
      // Scheduler 3
    if(scheduler.q ==  524286){
      if(l_button == 1 && userX.q >= 40){
        //userX.d = userX.q - 1;
        alu.a = c{21b0, userX.q};
        alu.b = 2;
        alu.alufn = b0000001;
        userX.d = alu.aluOUT[10:0];
        scheduler.d = 9;
         
      }
    } 
      
    if(scheduler.q ==  524285){
      if(r_button == 1 && userX.q <= 770){
        // userX.d = userX.q + 1;
        alu.a = c{21b0, userX.q};
        alu.b = 2;
        alu.alufn = b000000;
        userX.d = alu.aluOUT[10:0];
        scheduler.d = 8;
      } 
    }
    
    projChar.startX = userX.q;
    projChar.startY = userY.q;

    if(edge_detector.out){
      projChar.shot = 1;
    }
    

  
    
    if (pixel.q < 800 && line.q < 600) {
      red = bg.r || userChar.r || enemyChar.r || projChar.r;
      green = bg.g || userChar.g || enemyChar.g || projChar.g;
      blue = bg.b || userChar.b || enemyChar.b || projChar.b;


    } else {
      // outside visible frame
      red = 0;
      blue = 0;
      green = 0;
    }
      
      
  // horizontal sync
  if (pixel.q >= 800+56-1 && pixel.q <= 800+56-1+119) {
    hsync = 1;
  } else {
    hsync = 0;
  }

  // vertical refresh
  if (line.q >= 600+37-1 && line.q <= 600+37-1+5) {
    vsync = 1;
  } else {
    vsync = 0;
  }

  // advance pixel and line counters
  if (pixel.q == 800+56+120+64-1) {
    if (line.q == 600+37+6+23-1) {
      line.d = 0;
    } else {
      line.d = line.q + 1;
    }
    pixel.d = 0;
  } else {
    pixel.d = pixel.q + 1;
  }
    
  led[4:0] = c{u_button, d_button, l_button, r_button, a_button};
  }
}